# Descomplicando os Volumes no K8s.
### 06.1.	O que são volumes?
Para simplificar o seu entendimento nesse momento, volumes nada mais são do que um diretório dentro do Pod que pode ser utilizado para armazenar dados. Eles podem ser utilizados para armazenar dados que precisam ser persistidos, como por exemplo, dados de um banco de dados, ou dados de um sistema de arquivos distribuído.

Quando estamos falando sobre volumes no Kubernetes, precisamos entender que temos basicamente dois tipos de volumes, os **ephemeral volumes** e os **persistent volumes**.

Os **ephemeral volumes**, que inclusive já vimos durante o treinamento o **emptyDir**, são volumes que são criados e destruídos junto com o Pod. Ele é um volume também, porém com uma diferença, ele não é persistente. Caso ocorra algum problema com o Pod e ele seja removido, o emptyDir também será removido.

Agora quando estamos falando sobre volumes do tipo **persistent volumes**, estamos falando sobre volumes que são criados e não são destruídos junto com o Pod, eles são persistidos, são volumes que seus dados são mantidos mesmo que o Pod seja removido.

Esse tipo de volume é muito importante para aplicações que precisam armazenar dados que precisam ser mantidos mesmo que o Pod seja removido, como por exemplo, um banco de dados.

### 06.2.	O StorageClass.
Uma StorageClass no Kubernetes é um objeto que descreve e define diferentes classes de armazenamento disponíveis no cluster. Essas classes de armazenamento podem ser usadas para provisionar dinamicamente PersistentVolumes (PVs) de acordo com os requisitos dos PersistentVolumeClaims (PVCs) criados pelos usuários.

A StorageClass é útil para gerenciar e organizar diferentes tipos de armazenamento, como armazenamento em disco rápido e caro ou armazenamento em disco mais lento e barato. Além disso, a StorageClass pode ser usada para definir diferentes políticas de retenção, provisionamento e outras características de armazenamento específicas.

Os administradores do cluster podem criar e gerenciar várias StorageClasses para permitir que os usuários finais escolham a classe de armazenamento adequada para suas necessidades.

Cada StorageClass é definida com um provisionador, que é responsável por criar PersistentVolumes dinamicamente conforme necessário. Os provisionadores podem ser internos (fornecidos pelo próprio Kubernetes) ou externos (fornecidos por provedores de armazenamento específicos).

Inclusive os provisionadores podem ser diferentes para cada provedor de nuvem ou onde o Kubernetes está sendo executado.

**O que é provisioner?**  
O provisioner é o componente responsável por criar (provisionar) dinamicamente volumes de armazenamento quando o Kubernetes precisa deles.

Cada StorageClass possui um provisionador que determina qual plugin de volume é usado para provisionar PVs. Este campo deve ser especificado.

Para ver a lista completa de provisionadores, consulte a documentação do Kubernetes no link https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner.

**Trabalhando com StorageClass.**  
* **Ver os StorageClass existentes**: kubectl get storageclass  
* **Ver detalhes de um StorageClass**: kubectl describe storageclass

**Criando um StorageClass.**  
Para criar um StorageClass, crie um arquivo de manifesto **storageclass.yml** conforme o exemplo abaixo:  

<p align="center"><img width="339" height="119" alt="image" src="https://github.com/user-attachments/assets/954cdb77-0a39-4af1-9f6e-41305ef73395"/></p>

Abaixo, a explicação de cada parâmetro do StorageClass:

* **apiVersion**: define a versão da API do Kubernetes usada para objetos de storage.  
* **kind**: indica que esse manifesto cria um StorageClass.  
* **metadata**: informações que serão passados para o StorageClass.  
  * **name**: nome do StorageClass.  
* **provisioner**: qual provisionador será usado.  
* **reclaimPolicy**: esse campo define o que acontece com o volume real quando o PVC é deletado. Com **Retain**, o Kubernetes NÃO apaga o volume nem os dados quando o PersistentVolumeClaim (PVC) é deletado.  
* **volumeBindingMode**: controla quando o volume será associado ao PVC. Com WaitForFirstConsumer, o Kubernetes adiará o vínculo (bind) do volume até que exista um Pod que vá realmente usar esse volume.

**Para aplicar essa configuração, execute**: k apply -f  storageclass.yml  

Após aplicar a configuração, o StorageClass foi criado com sucesso.
<p align="center"><img width="570" height="24" alt="image" src="https://github.com/user-attachments/assets/0e1addc4-0ce7-4ea6-a9ab-c16f11156f43" /></p>

### 06.3.	PV (PersistentVolumes).
O PV é um objeto que representa um recurso de armazenamento físico em um cluster Kubernetes. Ele pode ser um disco rígido em um nó do cluster, um dispositivo de armazenamento em rede (NAS) ou mesmo um serviço de armazenamento em nuvem, como o AWS EBS ou Google Cloud Persistent Disk.

O PV é utilizado para fornecer armazenamento durável, ou seja, os dados armazenados no PV permanecem disponíveis mesmo quando o container é reiniciado ou movido para outro nó.

No Kubernetes, você pode usar várias soluções de armazenamento como Persistent Volumes (PVs). Essas soluções podem ser divididas em dois tipos: armazenamento local e armazenamento em rede.

**hostPath.**  
Um volume hostPath monta um arquivo ou diretório do sistema de arquivos do nó host em seu Pod. Isso não é algo que a maioria dos Pods precise, mas oferece uma solução alternativa poderosa para algumas aplicações.

⚠️ **Aviso.**  
O uso de volumes hostPath apresenta muito riscos de segurança. Se possível, evite usá-lo. Por exemplo, defina um [PersistentVolume](https://kubernetes.io/docs/concepts/storage/volumes/#local) local e use-o em vez de um volume.

Tenha cuidado ao usar volumes hostPath, sejam eles montados como somente leitura ou como leitura e gravação, porque:  

* O acesso ao sistema de arquivos do host pode expor credenciais privilegiadas do sistema (como as do kubelet) ou APIs privilegiadas (como o socket de tempo de execução do contêiner) que podem ser usadas para escapar do contêiner ou para atacar outras partes do cluster;

* Pods com configurações idênticas (como os criados a partir de um PodTemplate) podem se comportar de maneira diferente em nós diferentes devido a arquivos diferentes presentes nesses nós;

* O uso de volume **hostPath** não é tratado como uso de armazenamento efêmero. Você precisa monitorar o uso do disco por conta própria, pois o uso excessivo do disco levará à sobrecarga do nó;

Algumas utilizações para um(a) hostPath são:

* Executar um contêiner que precisa acessar componentes do sistema em nível de nó (como um contêiner que transfere logs do sistema para um local central, acessando esses logs usando uma montagem somente leitura de /var/log);

* Disponibilizar um arquivo de configuração armazenado no sistema host em modo somente leitura para um usuário.

**Armazenamento NFS.**  
Um volume nfs permite que um compartilhamento NFS (Network File System) existente seja montado em um Pod. Ao contrário de um compartilhamento de disco emptyDir, que é apagado quando um Pod é removido, o conteúdo de um volume nfs é preservado e o volume é simplesmente desmontado. Isso significa que um volume NFS pode ser pré-populado com dados e que esses dados podem ser compartilhados entre pods. O NFS pode ser montado por vários usuários simultaneamente.

**Trabalhando com PersistentVolume.**  
* **Para visualizar os PVs existentes**: kubectl get pv  
* **Para visualizar uma descrição do PV**: kubectl describe pv my-pv

**Criando um PV.**  
Para criar um PV, crie o arquivo **pv.yml** com o conteúdo abaixo:
<p align=center><img width="325" height="244" alt="image" src="https://github.com/user-attachments/assets/908ad925-1afc-41ec-a075-bd2c60ef8fda" /></p>

Para entender os parâmetros utilizados:

* **apiVersion**: indica a versão da API do Kubernetes usada para criar o recurso. A versão v1 é a API estável para criar recursos básicos (Pod, Service, ConfigMap).

* **kind**: define o tipo de recurso que será criado, nesse caso, PersistentVolume.

* **metadata**: informações que será passado para o PV.  
  * **labels**: rótulos usados para organização e seleção.   
  * **storage: lento**: o rótulo criado.  
  * **name: my-pv**: nome do PV  

* **spec**: especificações de como o PV deve se comportar.  
  * **capacity**: configuração de capacidade do PV.  
  * **storage:** 1Gi: PV será de 1GB.
 
* **accessModes**: aqui é informado de que forma os Pods irão acessar o PV.  
  * **ReadWriteOnce**: neste modo, o volume pode ser montado com leitura e escrita por apenas UM node por vez.  

* **persistentVolumeReclaimPolicy**: define o que acontece com um PersistentVolume (PV) quando o PersistentVolumeClaim (PVC) que o usava é deletado. Essa configuração trabalha com alguns parâmetros:  
  * **Retain**: mantém o volume e os dados. O PV não é apagado e os dados continuam existindo (mais seguro).  
  * **Delete**: apaga o volume imediatamente. Se o PVC é deletado, o PV é deletado e o Storage é deletado. Muito usado com provisionamento dinâmico.  
  * **Recycle**: apaga os dados e reaproveita o volume. Não é seguro e foi removido nas versões recentes.  

* **hostPath**: é o tipo de volume. Nesse caso, é o armazenamento local do host.  
  * **path**: é o caminho no sistema operacional do node onde dados ficam.  

* **StorageClassName**: nome do StorageClass existente.  

**Aplique essa configuração criada**: kubectl apply -f pv.yaml  

Após isso, o PV foi criado.  
<p align=center><img width="570" height="34" alt="image" src="https://github.com/user-attachments/assets/2074689a-e868-4ee7-8d9b-3b72388f5a3f" /></p>











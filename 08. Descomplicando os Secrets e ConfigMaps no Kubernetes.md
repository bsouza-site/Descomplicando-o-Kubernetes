# Descomplicando os Secrets e ConfigMaps no Kubernetes
#### 08.1. O que são as Secrets no Kubernetes?
Os Secrets fornecem uma maneira segura e flexível de gerenciar informações sensíveis, como senhas, tokens OAuth, chaves SSH e outros dados que você não quer expor nas configurações de seus aplicativos.

Um Secret é um objeto que contém um pequeno volume de informações sensíveis, como uma senha, um token ou uma chave. Essas informações podem ser consumidas por Pods ou usadas pelo sistema para realizar ações em nome de um Pod.
 
**Como os Secrets funcionam.**  
Os Secrets são armazenados no Etcd, o armazenamento de dados distribuído do Kubernetes. Por padrão, eles são armazenados sem criptografia, embora o Etcd suporte criptografia para proteger os dados armazenados nele. Além disso, o acesso aos Secrets é restrito por meio de Role-Based Access Control (RBAC), o que permite controlar quais usuários e Pods podem acessar quais Secrets.
Os Secrets podem ser montados em Pods como arquivos em volumes ou podem ser usados para preencher variáveis de ambiente para um container dentro de um Pod. Quando um Secret é atualizado, o Kubernetes não atualiza automaticamente os volumes montados ou as variáveis de ambiente que se referem a ele.

#### 08.2. Conhecendo todos os tipos de Secrets e o que é a codificação base64.  
Ao criar um Secret, você pode especificar o seu tipo utilizando o campo type do objeto Secret, ou algumas opções de linha de comando equivalentes no comando kubectl, quando disponíveis. O campo type de um Secret é utilizado para facilitar a manipulação programática de diferentes tipos de dados confidenciais.

O Kubernetes oferece vários tipos embutidos de Secret para casos de uso comuns. Estes tipos variam em termos de validações efetuadas e limitações que o Kubernetes impõe neles.

Abaixo, a tabela com os tipos de secrets e os principais casos de uso:
<p align="center"><img width="572" height="185" alt="image" src="https://github.com/user-attachments/assets/626cde78-82a2-4550-b524-7ac560f7d26c" /></p>

Veja a documentação completa na página do Kubernetes na seção [Secrets](https://kubernetes.io/pt-br/docs/concepts/configuration/secret/).

**Base64.**  
Base64 é um método de codificação que converte dados binários (como imagens, áudios ou documentos) em uma string de texto ASCII composta por 64 caracteres seguros (A-Z, a-z, 0-9, +, / e = para preenchimento). Ele é usado para transmitir dados binários com segurança em sistemas que suportam apenas texto, como e-mails (MIME) e arquivos JSON/HTML, sem corrupção.

Para codificar um texto no Linux, use o comando **base64**, como no exemplo abaixo:
<p align="center"><img width="190" height="36" alt="image" src="https://github.com/user-attachments/assets/19fb13a5-fcdb-40ae-b5a7-0dd7678d4391" /></p>

#### 08.3. Criando um Secret do tipo Opaque.  
Para criar um secret do tipo Opaque, inicie simulando um usuário e senha codificados com base64:

* echo -n "MySecret" | base64  
* echo -n "brsouza" | base64  

Agora, crie o arquivo **08_primeiro_secret.yaml** com o conteúdo abaixo:
<p align="center"><img width="204" height="134" alt="image" src="https://github.com/user-attachments/assets/803340f2-ef1b-47a3-bf59-3072ce51e28f" /></p>

Abaixo, a explicação dos parâmetros:

* **apiVersion**: define a versão da API do Kubernetes usada.  
* **kind**: diz ao Kubernetes que este objeto é um **Secret**.  
* **metadata**: informações relacionadas ao Secret.  
  * **name**: nome do **Secret**.  
* **type**: tipo do Secret, nesse caso, **Opaque**.  
* **data**: dados que serão armazenados no Secret.  
  * **username**: resultado do comando **echo -n "MySecret" | base64**  
  * **password**: resultado do comando **echo -n "brsouza" | base64**  

**Para aplicar essa configuração, execute**: kubectl apply -f 08_primeiro_secret.yaml  
**Para ver os secrets criados, execute**: kubectl get secrets  
**Para ver detalhes do secrets, execute**: kubectl describe secrets  

**Criando um secret manualmente.**  
**Para criar um secret manualmente, execute**: kubectl create secret generic secret-test **--from-literal**=username=brsouza **--from-literal**=password=MySecret

Abaixo, a explicação dos parâmetros:

* **generic**: usando generic, será criado uma secret do tipo Opaque.  
* **secret-test**: nome da Secret.  
* **--from-literal**: será usado informações passadas na linha de comando no formato chave=valor.  

#### 08.4. Utilizando o nosso Secret dentro de um Pod.  
Para utilizar um Secret em um Pod, crie o arquivo **08_pod_secret.yaml** com o conteúdo abaixo:  
<p align="center"><img width="269" height="309" alt="image" src="https://github.com/user-attachments/assets/95ac780c-a726-46b9-ba47-035014c295c4" /></p>

Abaixo, os principais parâmetros dessa configuração.

* **env**:  variáveis de ambiente que serão informados ao Pod.  
* **name**: nome da variável de ambiente dentro do container.  
* **valueFrom**: indica que o valor não é fixo, vem de uma fonte externa.  
* **secretKeyRef**: diz que a fonte é um Secret do Kubernetes.  
* **name**: nome da Secret.  
* **key**: a chave dentro da Secret.  

**Para aplicar essa configuração, execute**: kubectl apply -f 08_pod_secret.yaml  

Executando **kubectl describe pod pod-secret**, é possível visualizar as variáveis de ambiente criados nesse pod.  
<p align="center"><img width="569" height="47" alt="image" src="https://github.com/user-attachments/assets/d489ef41-f478-43b2-b5e6-779eaab3a2c2" /></p>

E acessando o container com **kubectl exec -it pod-secret -- bash** é possível visualizar as variáveis de ambiente com o comando **set**.
<p align="center"><img width="420" height="51" alt="image" src="https://github.com/user-attachments/assets/d45ef953-e972-4885-9f66-dc8c9d1cdbfd" /></p>

#### 08.5. Criando um Secret para autenticar no Dockerhub do tipo dockerconfigjson e usar imagens privadas.
Ao realizar login no Docker hub via linha de comando com o comando **docker login**, é gerado o arquivo de configuração **~/.docker/config.json**.

Nesta aula, será criado um Secret com este arquivo **config.json**. Para isso, siga os passos abaixo:

* **Crie uma string com o comando base64 do arquivo config.json:** base64 ~/.docker/config.json  
* Crie o arquivo **08_dockerhub_secret.yaml** com o conteúdo abaixo:  
<p align="center"><img width="566" height="137" alt="image" src="https://github.com/user-attachments/assets/f8354f7e-f6e0-46e5-a217-4a66b6cdd19e" /></p>

Os principais parâmetros são:

* **type**: tipo do Secret.  
* **data**: os dados armazenados no Secret.  
  * **.dockerconfigjson**: deve ser armazenado a string do **config.json** resultante do comando base64 **~/.docker/config.json**  

**Aplique essa configuração com o comando**: kubectl apply -f 08_dockerhub_secret.yaml

**Criando um Pod para usar imagem privada.**  
Agora, crie um manifesto **08_pod_image_private.yaml** para baixar uma imagem do meu docker hub usando uma imagem privada.  
<p align="center"><img width="312" height="162" alt="image" src="https://github.com/user-attachments/assets/26df3f5a-c741-45ef-9fc9-9676c71dc468" /></p>

Para entender os parâmetros nesse arquivo:

* **image**: a imagem presente no meu Dockerhub.  
* **imagePullSecrets**: indica quais credenciais o cluster deve usar para baixar (pull) imagens de container a partir de registries privados.  
  * **name**: nome do Secret que deve ser utilizado.  

**Agora, crie esse Pod com o comando**: kubectl apply -f 08_pod_image_private.yaml  

Verificando os eventos desse Pod com o comando **kubectl describe pod my-pod**, é possível verificar que a imagem foi baixada e o Pod foi criado com sucesso.
<p align="center"><img width="1059" height="147" alt="image" src="https://github.com/user-attachments/assets/4382e5cc-822e-44eb-ad53-0a07c040e0c3" /></p>

#### 08.6. Criando um Secret do tipo tls para armazenar um certificado e chave TLS.
Para criar um Secret TLS, você precisa ter um certificado TLS e uma chave privada, e você precisa codificar o certificado e a chave privada em base64, para então criar o Secret.

* **Crie o certificado e a chave**: openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout private.key -out certificate.key  

O Secret dessa vez será criado via linha de comando, para isso, execute:
* kubectl create secret **tls** my-web-server **--cert**=certificate.crt **--key**=private.key

Abaixo, a Secret do tipo TLS criada.
<p align="center"><img width="384" height="33" alt="image" src="https://github.com/user-attachments/assets/80e7e80a-08cf-41aa-a55b-aa91fa25bc0b" /></p>

Veja as informações do Secret com o comando **kubectl describe secret my-web-server**
<p align="center"><img width="246" height="178" alt="image" src="https://github.com/user-attachments/assets/245d4d29-0575-4ddf-ab6e-6246fb282d6e" /></p>

#### 08.7. O que são ConfigMaps?
ConfigMaps no Kubernetes são objetos usados para armazenar configurações não sensíveis de aplicações, separadas do código e das imagens.

Um ConfigMap é um objeto da API usado para armazenar dados não-confidenciais em pares chave-valor. Pods podem consumir ConfigMaps como variáveis de ambiente, argumentos de linha de comando ou como arquivos de configuração em um volume.

Um ConfigMap ajuda a desacoplar configurações vinculadas ao ambiente das imagens de contêiner, de modo a tornar aplicações mais facilmente portáveis.

#### 08.8. Criando um ConfigMap para adicionar um arquivo no Pod e configurar SSL no NGINX.
Inicie essa aula criando o arquivo de ConfigMap conforme exemplo abaixo:
<p align="center"><img width="460" height="384" alt="image" src="https://github.com/user-attachments/assets/a1315826-7e4f-4459-a550-445f31e20f0f" /></p>

Veja abaixo os parâmetros informados no arquivo:

* **data**: contém o conteúdo do ConfigMap. Nesse caso, o conteúdo é o arquivo **nginx.conf**.

**Aplique a configuração desse ConfigMap**: kubectl apply -f 08_configmap.yaml

Agora, é necessário utilizar esse ConfigMap em um manifesto para criar um Pod. Crie o arquivo **08_pod-configmap.yaml** conforme o exemplo abaixo:
<p align="center"><img width="338" height="500" alt="image" src="https://github.com/user-attachments/assets/66fa07f7-f735-4221-99ea-6bed6eeeff72" /></p>

Abaixo, os principais parâmetros desse arquivo:  

* **volumeMounts: define onde os volumes devem aparecer dentro do container.  
  * **name**: referência ao volume definido em volumes.  
  * **mountPath**: caminho exato do arquivo dentro do container.  
  * **subPath**: monta apenas um arquivo, não o diretório inteiro.  

* **volumes**: define a origem dos volumes usados acima.  
  * **name**: cria um volume baseado no ConfigMap nginx-config.  

* **name**: o nginx-tls é um volume baseado em um Secret.  
  * **secretName**: nome do Secret que será utilizado.  
  * **items**: mapeia chaves do Secret para nomes de arquivos, onde **tls.crt** foi para **certificate.crt** e **tls.key** foi mapeado para **private.key**.  

**Para aplicar essa configuração, execute**: kubectl apply -f 08_pod-configmap.yaml  
**Para ver o Pod criado**: kubectl get pod pod-configmap
<p align="center"><img width="392" height="36" alt="image" src="https://github.com/user-attachments/assets/6627a90d-0029-4797-8714-6171f0d5fbe4" /></p>

**Expondo o Pod.**
**Para expor o serviço nesse Pod, execute**: kubectl expose pods pod-configmap  
<p align="center"><img width="630" height="50" alt="image" src="https://github.com/user-attachments/assets/a1be5980-10c2-4901-8c8a-4d8cacc3b53e" /></p>

**Faça o port-forward**: kubectl port-forward services/pod-configmap 4443:443

# Descomplicando os Pods e Limites de Recursos.

### 02.1.  O que é um Pod?
Um Pod no Kubernetes é a menor unidade de execução, um grupo lógico de um ou mais containers (como Docker) que compartilham recursos como rede (um IP único) e armazenamento, rodando juntos no mesmo nó para facilitar a comunicação e o gerenciamento. É a abstração fundamental para rodar aplicações, e o Kubernetes gerencia esses pods, criando réplicas e substituindo falhas automaticamente para garantir a resiliência e escalabilidade do aplicativo.

A saída do comando **kubectl get pods** apresenta as informações abaixo:
<p align=Center><img width="545" height="101" alt="image" src="https://github.com/user-attachments/assets/4c38a28f-ca27-41c6-b646-435ebc2c260f" /></p>

Os campos acima indicam:  

* **nginx-deployment**: o deployment em execução.  
* **df69bb55**: é o hash do ReplicaSet. Esse valor é um hash gerado automaticamente pelo Kubernetes.  
* **x5w22**: sufixo único do Pod. É um identificador aleatório para diferenciar Pods do mesmo ReplicaSet.  

### 02.2. Os sensacionais kubectl get pods e o kubectl describe pods.  
Abaixo, os principais comandos para trabalhar com pods no Kubernetes.  

* **Ver os pods existentes no namespace atual**: kubectl get pods  
* **Ver os pods existentes em todos os namespaces**: kubectl get pods -A  
* **Ver mais detalhes de um pod**: kubectl get pods -A -o wide  
* **Ficar acompanhando os pods na tela**: kubectl get pods -A -w  
* **Ver a saída de um pod em formato YAML**: kubectl get pods nginx -o yaml  
* **Ver os pods de uma namespace específica**: kubectl get pods -n kube-system  
* **Ver mais informações do comando**: kubectl get pods -h  
* **Ver informações detalhadas de um pod**: kubectl describe pods  

**Obs**: se eu escrevi algum comando iniciando com **k**, esse é o alias criado para o **kubectl**  

**kubectl describe**  
O **kubectl describe** é um comando do Kubernetes usado para exibir informações detalhadas e em tempo real sobre um recurso do cluster.  

Ele é essencial para debug, análise de problemas e entendimento do estado real dos recursos. Ele pode ser usado para descrever vários recursos do Kubernetes, como pods, nodes...  

**kubectl logs**  
O **kubectl logs** é o comando do Kubernetes usado para visualizar os logs gerados por containers que rodam dentro de Pods. Ele é essencial para debug de aplicações, análise de erros e verificação de comportamento em tempo real.

* **Para ver o log de um pod do NGINX (exemplo), execute**: kubectl logs nginx  
* **Para ficar acompanhando os logs na tela**: kubectl logs nginx -f **(--follow)**  
* **Para ver os logs de um container específico**: kubectl logs nginx -c **(--container)**  

### 02.3. Conhecendo o kubectl attach e o kubectl exec.  
**kubectl attach**  
O **kubectl attach** é um comando do Kubernetes usado para anexar seu terminal ao processo principal de um container que já está em execução dentro de um Pod.  

Ele permite interagir diretamente com a aplicação, como se você estivesse rodando o processo localmente.

**Para utilizar o kubectl attach para acessar o terminal de um pod, execute**: kubectl attach girus-1 -c girus-1 -ti  

* **-c (--container)**: informar o nome do container do Pod que será acessado. Se omitir essa opção, será acessado o primeiro container no pod.  
* O parâmetro **t (tty)** faz com que o shell se comporte como um terminal real.  
* O parâmetro **i** mantém a entrada padrão aberta e permite digitar comandos e enviar input para o container (ou pod).  

Uma limitação do **kubectl attach** é que ao sair do Pod com **Ctrl + C**, o Pod morre. Por isso, é recomendado utilizar o **kubectl exec**.  

**kubectl exec**  
O **kubectl exec** é um comando do Kubernetes usado para executar comandos dentro de um container que já está rodando em um Pod. Ele é muito utilizado para debug, troubleshooting e inspeção de aplicações em execução.

**Para acessar um pod com o bash, execute:** kubectl exec **-ti** strigus -- **bash**   
* O parâmetro **t (tty)** faz com que o shell se comporte como um terminal real.  
* O parâmetro **i** mantém a entrada padrão aberta e permite digitar comandos e enviar input para o conteiner (ou pod).  
* Esse **--** bash é o comando que será executado, podendo ser executado outros comandos...

### 02.4. Criando o nosso primeiro pod multicontainer utilizando um manifesto.
**Para esta aula, crie um arquivo YAML contendo as especificações de um pod:** k run girus --image alpine --dry-run=client -o yaml > pod.yaml
<p align="center"><img width="206" height="228" alt="image" src="https://github.com/user-attachments/assets/a2981ef2-19e1-448e-9f7b-4c925001519b" /></p>

Após o comando, foi criado o arquivo de manifesto acima... Nas linhas abaixo, vamos entender o que significa cada parâmetro:

* **apiVersion**: indica a versão da API do Kubernetes usada para criar o recurso. A versão **v1** é a API estável para criar recursos básicos (Pod, Service, ConfigMap).  
* **kind**: define o tipo de recurso que será criado, nesse caso, **Pod**.  
* **metadata**: informações relacionadas ao **Pod**.  
  * **labels**: rótulos usados para organização e seleção.  
  * **run**: apenas mais um rótulo. Dentro de **labels**, pode ser criado outros, como **service: webserver**  
  * **name**: nome do Pod. Deve ser único dentro do namespace.  
* **spec**: especificações de como o Pod deve executar.  
  * **containers**: lista de containeres dentro do pod.  
  * **image**: qual imagem será utilizada nesse container.  
  * **name**: nome lógico do container.  
  * **resources**: define limites e requisições de recursos (CPU/Memória). Como neste exemplo está vazio, nenhum limite foi definido.  
* **dnsPolicy**: define como o DNS funciona dentro do Pod. O **ClusterFirst** é o padrão e indica que o pod irá tentar resolver endereços de serviços externos usando o DNS do cluster (CoreDNS).  
* **restartPolicy**: define quando o Pod será reiniciado. **Always** indica que será reiniciado sempre que o container morrer e esse é o padrão para pods e deployments.  
* **status**: campo gerenciado pelo Kubernetes, nunca deve ser definido manualmente... no exemplo acima, pode ser apagado.

**Para aplicar essas configurações, podemos usar dois comandos:**
* **kubectl create**: cria os recursos definidos nesse manifesto.  
* **kubectl apply**: é o mais recomendado. Cria os recursos definidos no manifesto e atualiza os recursos, se necessário.  

**Para aplicar a configuração, execute**: kubectl apply -f **(--filename)** pod.yaml  
**É possível remover um recurso também**: kubectl delete -f **(--filename)** pod.yaml  

### 02.5. Limitando o consumo de recursos de CPU e memória.  
Neste momento, iremos editar o arquivo de manifesto anterior para trabalhar com limites de recursos.  

No Kubernetes, o gerenciamento de recursos é essencial para garantir a estabilidade e eficiência de aplicações em execução. Requests e Limits são mecanismos que permitem definir, respectivamente, a alocação mínima e máxima de recursos (CPU e memória) para containeres.  

No Kubernetes, **requests** e **limits** são usados para gerenciar os recursos de CPU e memória que os containeres podem usar. Eles ajudam a garantir que os recursos do cluster sejam utilizados de maneira eficiente e que os containeres não consumam mais recursos do que o necessário.  

**Requests.**  
Os **requests** especificam a quantidade mínima de CPU e memória que um Pod ou container precisa para funcionar. Ao configurar requests, você está reservando essa quantidade de recursos do total disponível no cluster para uma determinada aplicação. O Kubernetes usa esses valores para decidir em qual nó do cluster o container será agendado. Se um nó não tiver recursos suficientes para atender aos requests de um container, o Kubernetes não agendará o container nesse nó.  

**Limits.**  
Os **limits** especificam a quantidade máxima de CPU e memória que um Pod ou container pode usar. Se um container tentar usar mais recursos do que os especificados nos limits, ele será restringido. Para a CPU, o container será limitado ao valor máximo especificado. Para a memória, se o container tentar usar mais do que o limite, ele será encerrado (killed) pelo Kubernetes.  

Para trabalhar com limites de recursos, devemos editar os campos resources do manifesto. Abaixo, o novo manifesto criado.  
<p align="center"><img width="212" height="358" alt="image" src="https://github.com/user-attachments/assets/5726a905-a4dc-4966-81cf-e2b725385533" /></p>

Para entender os novos parâmetros passados para o manifesto:

* **args**: define os argumentos passados para o comando principal do container. Eles funcionam como parâmetros de linha de comando.  
* **resources**: define limites e requisições de recursos (CPU/Memória).  
  * **limits**: define o máximo de recursos que o container pode usar. Nesse caso, **cpu** e **memória**.  
  * **requests**: define o mínimo de recursos garantidos para o container. O scheduler do Kubernetes usa esses valores para decidir em qual nó o Pod pode rodar.

**Para aplicar este manifesto**: k apply -f pod_2.yaml

Após aplicar o manifesto, é possível visualizar as informações de limites utilizando o comando **kubectl describe pod**  
<p align="center"><img width="178" height="100" alt="image" src="https://github.com/user-attachments/assets/767d291d-0963-4f1e-be59-3e711458cb63" /></p>

**kubectl edit**  
O **kubectl edit** é um comando do Kubernetes usado para editar um recurso diretamente no cluster, abrindo o manifesto dele em um editor de texto (normalmente o vi, a menos que você configure outro).

Utilizando o comando **kubectl edit**, você edita o arquivo YAML do recurso em tempo real, e quando salva, o Kubernetes aplica as mudanças imediatamente.
